use crate::{
    globals::STRING_INTERNER,
    hir::types::{
        checked_declaration::CheckedParam,
        checked_type::{StructKind, Type},
    },
};

#[derive(Debug, Clone, Copy)]
pub struct Layout {
    pub size: usize,
    pub alignment: usize,
}

impl Layout {
    pub fn new(size: usize, alignment: usize) -> Self {
        Self { size, alignment }
    }
}

const PTR_SIZE: usize = std::mem::size_of::<usize>();
const PTR_ALIGN: usize = std::mem::align_of::<usize>();

/// IMPORTANT: Make sure user-defined structs are packed (via pack_struct)
/// before calling this function if you want minimized padding.
pub fn get_layout_of(ty: &Type) -> Layout {
    match ty {
        Type::Void => Layout::new(0, 1),
        Type::Bool | Type::U8 | Type::I8 => Layout::new(1, 1),
        Type::U16 | Type::I16 => Layout::new(2, 2),
        Type::U32 | Type::I32 | Type::F32 => Layout::new(4, 4),
        Type::U64 | Type::I64 | Type::F64 => Layout::new(8, 8),
        Type::Pointer(_) | Type::Fn(_) | Type::USize | Type::ISize => {
            Layout::new(PTR_SIZE, PTR_ALIGN)
        }
        Type::UnionPayload(variants) => {
            let mut max_size = 0;
            let mut max_align = 1;
            for v in variants {
                let layout = get_layout_of(v);
                max_size = max_size.max(layout.size);
                max_align = max_align.max(layout.alignment);
            }
            Layout {
                size: max_size,
                alignment: max_align,
            }
        }
        Type::Tag(_) => Layout::new(0, 1),
        Type::Unknown | Type::Never => Layout::new(0, 1),

        Type::Struct(s) => {
            let fields = s.fields();
            let types: Vec<&Type> = fields.iter().map(|(_, ty)| ty).collect();

            calculate_fields_layout(&types)
        }
    }
}

pub fn get_alignment_of(ty: &Type) -> usize {
    get_layout_of(ty).alignment
}

/// Helper to calculate layout of fields placed sequentially in memory,
/// handles padding between fields and at the end of the struct
fn calculate_fields_layout(field_types: &[&Type]) -> Layout {
    let mut current_offset = 0;
    let mut max_alignment = 1;

    for ty in field_types {
        let field_layout = get_layout_of(ty);

        max_alignment = std::cmp::max(max_alignment, field_layout.alignment);

        let padding = (field_layout.alignment
            - (current_offset % field_layout.alignment))
            % field_layout.alignment;

        current_offset += padding;
        current_offset += field_layout.size;
    }

    let padding_end = (max_alignment - (current_offset % max_alignment)) % max_alignment;
    let total_size = current_offset + padding_end;

    Layout::new(total_size, max_alignment)
}

pub fn pack_struct(struct_kind: StructKind) -> StructKind {
    match struct_kind {
        StructKind::UserDefined(mut fields) => {
            sort_fields(&mut fields);
            StructKind::UserDefined(fields)
        }
        other => other,
    }
}

fn sort_fields(fields: &mut [CheckedParam]) {
    fields.sort_by(|field_a, field_b| {
        let align_a = get_alignment_of(&field_a.ty);
        let align_b = get_alignment_of(&field_b.ty);

        align_b.cmp(&align_a).then_with(|| {
            let name_a = STRING_INTERNER.resolve(field_a.identifier.name);
            let name_b = STRING_INTERNER.resolve(field_b.identifier.name);

            name_a.cmp(&name_b)
        })
    });
}
